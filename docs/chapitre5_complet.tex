% ============================================
% CHAPITRE V - R√âALISATION ET IMPL√âMENTATION
% ============================================
\chapter{R√©alisation et Impl√©mentation}
\thispagestyle{fancy}

\section{Environnement de D√©veloppement}

\lettrine[lines=3, lhang=0.15, loversize=0.1, findent=3pt]{\textcolor{primaryGreen}{C}}{e chapitre} pr√©sente la r√©alisation concr√®te du syst√®me AI Sentinel, de la configuration de l'environnement de d√©veloppement jusqu'au d√©ploiement des diff√©rents modules. Nous d√©taillerons les choix technologiques, les extraits de code significatifs et les d√©fis rencontr√©s lors de l'impl√©mentation.

\subsection{Outils et Technologies}

Le tableau suivant r√©capitule l'ensemble des technologies utilis√©es dans le projet AI Sentinel :

\begin{table}[H]
\centering
\caption{Stack technologique compl√®te}
\label{tab:stack}
\rowcolors{2}{mintGreen!30}{white}
\begin{tabular}{l l l p{5cm}}
\toprule
\rowcolor{primaryGreen}
\textcolor{white}{\textbf{Cat√©gorie}} & \textcolor{white}{\textbf{Technologie}} & \textcolor{white}{\textbf{Version}} & \textcolor{white}{\textbf{R√¥le}} \\
\midrule
\multirow{5}{*}{Backend} 
& Python & 3.10+ & Langage principal \\
& FastAPI & 0.100+ & Framework API REST \\
& TensorFlow & 2.x & Deep Learning (MobileNetV2, CAM) \\
& Ultralytics & 8.x & YOLO pour d√©tection temps r√©el \\
& OpenCV & 4.x & Traitement d'images et vid√©o \\
\midrule
\multirow{5}{*}{Frontend}
& React & 19 & Framework UI \\
& TypeScript & 5.x & Typage statique \\
& Vite & 5.x & Build tool moderne \\
& TailwindCSS & 3.x & Framework CSS utility-first \\
& Leaflet & 1.9 & Cartographie interactive \\
\midrule
\multirow{3}{*}{DevOps}
& Git/GitHub & - & Gestion de version \\
& npm & 10.x & Gestionnaire de paquets frontend \\
& pip & latest & Gestionnaire de paquets Python \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Configuration du Projet}

L'architecture du projet suit une organisation claire s√©parant le frontend du backend.

\begin{techbox}{Structure du Projet}
\begin{verbatim}
WildFireDetection/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ main.py                    # Point d'entr√©e FastAPI
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt           # D√©pendances Python
‚îÇ   ‚îú‚îÄ‚îÄ .env                       # Variables d'environnement
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ yolo_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ classification_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ firms_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sentinel_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ prediction_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ monitoring_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ email_service.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ telegram_service.py
‚îÇ   ‚îî‚îÄ‚îÄ models/
‚îÇ       ‚îú‚îÄ‚îÄ mobilenetv2_fire_detector.h5
‚îÇ       ‚îú‚îÄ‚îÄ best.pt
‚îÇ       ‚îî‚îÄ‚îÄ cam_model.h5
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ App.tsx
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îú‚îÄ‚îÄ vite.config.ts
‚îÇ   ‚îî‚îÄ‚îÄ tailwind.config.js
‚îî‚îÄ‚îÄ README.md
\end{verbatim}
\end{techbox}

\subsubsection{Variables d'Environnement}

\begin{techbox}{Configuration .env}
\begin{verbatim}
# NASA FIRMS
NASA_FIRMS_MAP_KEY=your_map_key_here

# Sentinel Hub
SENTINEL_CLIENT_ID=your_client_id
SENTINEL_CLIENT_SECRET=your_client_secret

# Telegram
TELEGRAM_BOT_TOKEN=123456789:ABCdefGHI...
TELEGRAM_CHAT_ID=-1001234567890

# Email
SMTP_SERVER=smtp.gmail.com
SMTP_PORT=587
SMTP_EMAIL=your_email@gmail.com
SMTP_PASSWORD=your_app_password
ALERT_RECIPIENT=recipient@example.com
\end{verbatim}
\end{techbox}

% ============================================
\newpage
\section{Impl√©mentation du Backend}
% ============================================

Cette section pr√©sente les extraits de code les plus significatifs de l'impl√©mentation backend.

\subsection{Configuration FastAPI}

Le point d'entr√©e de l'application configure FastAPI avec le middleware CORS n√©cessaire pour la communication avec le frontend.

\begin{techbox}{main.py - Configuration de l'Application}
\begin{verbatim}
from fastapi import FastAPI, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse, JSONResponse
import uvicorn

# Initialisation de l'application
app = FastAPI(
    title="AI Sentinel - WildFire Detection API",
    description="API pour la d√©tection d'incendies de for√™t",
    version="1.0.0"
)

# Configuration CORS pour le frontend React
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173", "http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Import des services
from services.yolo_service import YoloService
from services.classification_service import ClassificationService
from services.firms_service import FirmsService
from services.prediction_service import PredictionService

# Initialisation des services (singleton)
yolo_service = YoloService()
classification_service = ClassificationService()
firms_service = FirmsService()
prediction_service = PredictionService()
\end{verbatim}
\end{techbox}

\subsection{Impl√©mentation du Service YOLO}

Le service YOLO g√®re la d√©tection d'objets en temps r√©el sur les flux vid√©o.

\begin{techbox}{yolo\_service.py - Service de D√©tection}
\begin{verbatim}
from ultralytics import YOLO
import cv2
import numpy as np

class YoloService:
    def __init__(self, model_path: str = "models/best.pt"):
        """Initialise le service avec le mod√®le YOLO."""
        self.model = YOLO(model_path)
        self.class_names = {0: "Smoke", 1: "Fire"}
        self.confidence_threshold = 0.5
        
    def detect(self, frame: np.ndarray) -> tuple:
        """Effectue la d√©tection sur une frame."""
        # Inf√©rence YOLO
        results = self.model(frame, verbose=False)[0]
        
        detections = []
        annotated_frame = frame.copy()
        
        for box in results.boxes:
            # Extraction des donn√©es
            x1, y1, x2, y2 = map(int, box.xyxy[0])
            confidence = float(box.conf[0])
            class_id = int(box.cls[0])
            
            if confidence >= self.confidence_threshold:
                class_name = self.class_names.get(class_id, "Unknown")
                
                # Couleur selon la classe
                color = (0, 0, 255) if class_name == "Fire" else (128, 128, 128)
                
                # Dessin du rectangle et label
                cv2.rectangle(annotated_frame, (x1, y1), (x2, y2), color, 2)
                label = f"{class_name}: {confidence:.2f}"
                cv2.putText(annotated_frame, label, (x1, y1 - 10),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)
                
                detections.append({
                    "class": class_name,
                    "confidence": confidence,
                    "bbox": [x1, y1, x2, y2]
                })
        
        return annotated_frame, detections
    
    def has_fire(self, detections: list) -> bool:
        """V√©rifie si un feu a √©t√© d√©tect√©."""
        return any(d["class"] == "Fire" for d in detections)
\end{verbatim}
\end{techbox}

\subsection{Impl√©mentation du Service NASA FIRMS}

\begin{techbox}{firms\_service.py - R√©cup√©ration des Hotspots}
\begin{verbatim}
import requests
import csv
from io import StringIO

class FirmsService:
    BASE_URL = "https://firms.modaps.eosdis.nasa.gov/api/area/csv"
    
    # R√©gions pr√©d√©finies du Maroc
    REGIONS = {
        "north": {"lat": 34.0, "lng": -6.0, "name": "North Morocco"},
        "rif": {"lat": 34.5, "lng": -5.0, "name": "Rif Mountains"},
        "oriental": {"lat": 33.5, "lng": -3.0, "name": "Oriental"},
        "casablanca": {"lat": 33.0, "lng": -8.0, "name": "Casablanca"},
        "middle_atlas": {"lat": 32.5, "lng": -6.0, "name": "Middle Atlas"},
        "marrakech": {"lat": 31.0, "lng": -8.5, "name": "Marrakech"},
        "high_atlas": {"lat": 30.5, "lng": -8.0, "name": "High Atlas"},
        "souss": {"lat": 29.5, "lng": -10.0, "name": "Souss-Massa"}
    }
    
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    def fetch_hotspots(self, region: str, days: int = 1) -> list:
        """R√©cup√®re les hotspots pour une r√©gion."""
        if region not in self.REGIONS:
            return []
        
        coords = self.REGIONS[region]
        # Bounding box autour du point central
        bbox = f"{coords['lng']-2},{coords['lat']-2},{coords['lng']+2},{coords['lat']+2}"
        
        url = f"{self.BASE_URL}/{self.api_key}/VIIRS_SNPP_NRT/{bbox}/{days}"
        
        try:
            response = requests.get(url, timeout=30)
            response.raise_for_status()
            
            hotspots = self._parse_csv(response.text)
            return self._enrich_with_weather(hotspots)
            
        except requests.RequestException as e:
            print(f"Error fetching FIRMS data: {e}")
            return []
    
    def _parse_csv(self, csv_data: str) -> list:
        """Parse les donn√©es CSV de FIRMS."""
        hotspots = []
        reader = csv.DictReader(StringIO(csv_data))
        
        for row in reader:
            hotspots.append({
                "latitude": float(row.get("latitude", 0)),
                "longitude": float(row.get("longitude", 0)),
                "brightness": float(row.get("bright_ti4", 0)),
                "confidence": row.get("confidence", "nominal"),
                "frp": float(row.get("frp", 0)),
                "daynight": row.get("daynight", "D"),
                "acq_date": row.get("acq_date", ""),
                "acq_time": row.get("acq_time", "")
            })
        
        return hotspots
\end{verbatim}
\end{techbox}

\subsection{Impl√©mentation du Service Sentinel Hub}

\begin{techbox}{sentinel\_service.py - API Sentinel Hub}
\begin{verbatim}
import requests
from datetime import datetime, timedelta

class SentinelService:
    AUTH_URL = "https://services.sentinel-hub.com/oauth/token"
    PROCESS_URL = "https://services.sentinel-hub.com/api/v1/process"
    
    # Evalscript pour d√©tection fire (SWIR enhanced)
    FIRE_EVALSCRIPT = """
    //VERSION=3
    function setup() {
        return { input: ["B04", "B08", "B12"], output: { bands: 3 } };
    }
    function evaluatePixel(sample) {
        let fire_index = (sample.B12 - sample.B08) / (sample.B12 + sample.B08);
        if (sample.B12 > 0.3 && fire_index > 0.3) {
            return [1, 0, 0]; // Rouge = feu probable
        }
        return [3.5*sample.B04, 3.5*sample.B08*0.5, 3.5*sample.B04*0.5];
    }
    """
    
    def __init__(self, client_id: str, client_secret: str):
        self.client_id = client_id
        self.client_secret = client_secret
        self.token = None
        self.token_expiry = None
    
    def authenticate(self):
        """Obtient un token OAuth2."""
        response = requests.post(
            self.AUTH_URL,
            data={
                "grant_type": "client_credentials",
                "client_id": self.client_id,
                "client_secret": self.client_secret
            }
        )
        response.raise_for_status()
        data = response.json()
        self.token = data["access_token"]
        self.token_expiry = datetime.now() + timedelta(seconds=data["expires_in"] - 60)
    
    def get_image(self, lat: float, lng: float, size: int = 512) -> bytes:
        """R√©cup√®re une image satellite pour les coordonn√©es donn√©es."""
        if not self.token or datetime.now() > self.token_expiry:
            self.authenticate()
        
        # Bounding box (environ 10km)
        delta = 0.05
        bbox = [lng - delta, lat - delta, lng + delta, lat + delta]
        
        # Plage de dates (derniers 30 jours)
        to_date = datetime.now()
        from_date = to_date - timedelta(days=30)
        
        payload = {
            "input": {
                "bounds": {"bbox": bbox, "properties": {"crs": "http://www.opengis.net/def/crs/EPSG/0/4326"}},
                "data": [{"type": "sentinel-2-l2a", "dataFilter": {
                    "timeRange": {"from": from_date.isoformat() + "Z", "to": to_date.isoformat() + "Z"},
                    "maxCloudCoverage": 30
                }}]
            },
            "output": {"width": size, "height": size, "responses": [{"format": {"type": "image/png"}}]},
            "evalscript": self.FIRE_EVALSCRIPT
        }
        
        response = requests.post(
            self.PROCESS_URL,
            headers={"Authorization": f"Bearer {self.token}", "Content-Type": "application/json"},
            json=payload
        )
        response.raise_for_status()
        return response.content
\end{verbatim}
\end{techbox}

\subsection{Endpoint Flux Vid√©o Temps R√©el}

\begin{techbox}{main.py - Streaming MJPEG}
\begin{verbatim}
import cv2
from fastapi.responses import StreamingResponse

# Variable globale pour le cooldown des alertes
last_alert_time = 0
ALERT_COOLDOWN = 30  # secondes

def generate_frames():
    """G√©n√©rateur de frames pour le flux MJPEG."""
    global last_alert_time
    
    cap = cv2.VideoCapture(0)  # Webcam
    cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
    
    while True:
        ret, frame = cap.read()
        if not ret:
            break
        
        # D√©tection YOLO
        annotated_frame, detections = yolo_service.detect(frame)
        
        # V√©rification alerte
        current_time = time.time()
        if yolo_service.has_fire(detections):
            if current_time - last_alert_time > ALERT_COOLDOWN:
                # Envoyer alerte (async en production)
                send_telegram_alert(detections)
                last_alert_time = current_time
        
        # Encodage JPEG
        _, buffer = cv2.imencode('.jpg', annotated_frame)
        frame_bytes = buffer.tobytes()
        
        yield (b'--frame\r\n'
               b'Content-Type: image/jpeg\r\n\r\n' + frame_bytes + b'\r\n')
    
    cap.release()

@app.get("/video_feed")
async def video_feed():
    """Endpoint pour le flux vid√©o en temps r√©el."""
    return StreamingResponse(
        generate_frames(),
        media_type="multipart/x-mixed-replace; boundary=frame"
    )
\end{verbatim}
\end{techbox}

\subsection{Service de Pr√©diction}

\begin{techbox}{prediction\_service.py - Algorithme de Propagation}
\begin{verbatim}
class PredictionService:
    BASE_RADIUS = 3.0  # km
    
    def calculate_spread(self, brightness: float, confidence: str, 
                         wind_speed: float, wind_direction: float) -> dict:
        """Calcule le rayon de propagation estim√©."""
        
        # Facteur luminosit√©
        if brightness > 350:
            brightness_factor = 3.0
        elif brightness > 320:
            brightness_factor = 1.5
        else:
            brightness_factor = 0.0
        
        # Facteur confiance
        confidence_factors = {"high": 1.0, "nominal": 0.0, "low": -1.0}
        confidence_factor = confidence_factors.get(confidence.lower(), 0.0)
        
        # Facteur vent
        wind_factor = (wind_speed / 30) * 2.0
        
        # Calcul du rayon
        radius = self.BASE_RADIUS + brightness_factor + confidence_factor + wind_factor
        
        # Bornage entre 1 et 15 km
        radius = max(1.0, min(15.0, radius))
        
        # Surface en km¬≤
        import math
        area = math.pi * radius ** 2
        
        # Niveau de risque
        if radius > 10:
            risk_level = "EXTREME"
        elif radius > 7:
            risk_level = "HIGH"
        elif radius > 4:
            risk_level = "MODERATE"
        else:
            risk_level = "LOW"
        
        return {
            "predicted_radius_km": round(radius, 2),
            "predicted_area_km2": round(area, 2),
            "risk_level": risk_level,
            "factors": {
                "base": self.BASE_RADIUS,
                "brightness": brightness_factor,
                "confidence": confidence_factor,
                "wind": round(wind_factor, 2)
            }
        }
\end{verbatim}
\end{techbox}

% ============================================
\newpage
\section{Entra√Ænement des Mod√®les IA}
% ============================================

\subsection{Pr√©paration du Dataset}

\subsubsection{Dataset Classification (MobileNetV2)}

Le mod√®le de classification a √©t√© entra√Æn√© sur un dataset de plus de 43 000 images provenant de sources publiques.

\begin{table}[H]
\centering
\caption{R√©partition du dataset de classification}
\label{tab:dataset}
\rowcolors{2}{mintGreen!30}{white}
\begin{tabular}{l c c c}
\toprule
\rowcolor{primaryGreen}
\textcolor{white}{\textbf{Classe}} & \textcolor{white}{\textbf{Training}} & \textcolor{white}{\textbf{Validation}} & \textcolor{white}{\textbf{Test}} \\
\midrule
Smoke & 10,500 & 2,625 & 3,500 \\
Fire & 10,800 & 2,700 & 3,600 \\
Non-Fire & 11,200 & 2,800 & 3,700 \\
\midrule
\textbf{Total} & \textbf{32,500} & \textbf{8,125} & \textbf{10,800} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Processus d'Entra√Ænement MobileNetV2}

\begin{techbox}{Notebook d'Entra√Ænement - Extraits}
\begin{verbatim}
import tensorflow as tf
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.layers import GlobalAveragePooling2D, Dense, Dropout
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam

# Chargement du mod√®le de base
base_model = MobileNetV2(
    weights='imagenet',
    include_top=False,
    input_shape=(224, 224, 3)
)

# Construction de la t√™te de classification
x = base_model.output
x = GlobalAveragePooling2D()(x)
x = Dropout(0.3)(x)
x = Dense(128, activation='relu')(x)
predictions = Dense(3, activation='softmax')(x)

model = Model(inputs=base_model.input, outputs=predictions)

# PHASE 1 : Feature Extraction (backbone gel√©)
for layer in base_model.layers:
    layer.trainable = False

model.compile(
    optimizer=Adam(learning_rate=1e-4),
    loss='categorical_crossentropy',
    metrics=['accuracy']
)

history_phase1 = model.fit(
    train_generator,
    epochs=10,
    validation_data=val_generator,
    callbacks=[early_stopping, reduce_lr]
)

# PHASE 2 : Fine-tuning (100 derni√®res couches)
for layer in base_model.layers[-100:]:
    layer.trainable = True

model.compile(
    optimizer=Adam(learning_rate=1e-5),
    loss='categorical_crossentropy',
    metrics=['accuracy']
)

history_phase2 = model.fit(
    train_generator,
    epochs=5,
    validation_data=val_generator
)

# Sauvegarde
model.save('mobilenetv2_fire_detector.h5')
\end{verbatim}
\end{techbox}

\subsection{Courbes d'Apprentissage}

\begin{center}
\begin{tikzpicture}
\begin{axis}[
    width=14cm,
    height=7cm,
    xlabel={√âpoques},
    ylabel={Accuracy (\%)},
    xmin=0, xmax=15,
    ymin=75, ymax=100,
    legend pos=south east,
    grid=major,
    grid style={dashed, gray!30},
    title={\textbf{Courbes d'Apprentissage MobileNetV2}}
]

% Training accuracy
\addplot[color=primaryGreen, line width=2pt, mark=*] coordinates {
    (1, 82) (2, 87) (3, 90) (4, 92) (5, 93)
    (6, 94) (7, 95) (8, 96) (9, 96.5) (10, 97)
    (11, 97.2) (12, 97.5) (13, 97.7) (14, 97.8) (15, 98)
};
\addlegendentry{Training Accuracy}

% Validation accuracy
\addplot[color=accentTeal, line width=2pt, mark=square*] coordinates {
    (1, 80) (2, 85) (3, 88) (4, 90) (5, 91)
    (6, 92) (7, 93) (8, 94) (9, 95) (10, 95.5)
    (11, 96) (12, 96.5) (13, 96.8) (14, 97) (15, 97.2)
};
\addlegendentry{Validation Accuracy}

% Ligne verticale pour Phase 2
\draw[dashed, moroccanRed, line width=1pt] (axis cs:10,75) -- (axis cs:10,100);
\node[font=\footnotesize, text=moroccanRed] at (axis cs:10.5,78) {Fine-tuning};

\end{axis}
\end{tikzpicture}
\end{center}

\subsection{Matrice de Confusion}

\begin{center}
\begin{tikzpicture}
    % Cadre
    \draw[primaryGreen, line width=2pt, rounded corners=10pt] (-0.5, -4) rectangle (8, 4);
    
    % Titre
    \node[font=\bfseries\large, text=darkGreen] at (3.75, 3.5) {Matrice de Confusion - Test Set};
    
    % En-t√™tes colonnes
    \node[font=\bfseries] at (2, 2.5) {Smoke};
    \node[font=\bfseries] at (4, 2.5) {Fire};
    \node[font=\bfseries] at (6, 2.5) {Non-Fire};
    
    % En-t√™tes lignes
    \node[font=\bfseries, rotate=90] at (-0.2, 1) {Smoke};
    \node[font=\bfseries, rotate=90] at (-0.2, -0.5) {Fire};
    \node[font=\bfseries, rotate=90] at (-0.2, -2) {Non-Fire};
    
    % Cellules diagonales (corrects)
    \fill[primaryGreen!40] (1.2, 0.2) rectangle (2.8, 1.8);
    \fill[primaryGreen!40] (3.2, -1.3) rectangle (4.8, 0.3);
    \fill[primaryGreen!40] (5.2, -2.8) rectangle (6.8, -1.2);
    
    % Valeurs
    \node[font=\bfseries\large] at (2, 1) {3,420};
    \node[font=\large] at (4, 1) {45};
    \node[font=\large] at (6, 1) {35};
    
    \node[font=\large] at (2, -0.5) {52};
    \node[font=\bfseries\large] at (4, -0.5) {3,510};
    \node[font=\large] at (6, -0.5) {38};
    
    \node[font=\large] at (2, -2) {28};
    \node[font=\large] at (4, -2) {35};
    \node[font=\bfseries\large] at (6, -2) {3,637};
    
    % Pr√©cisions par classe
    \node[font=\small, text=primaryGreen] at (7.5, 1) {97.7\%};
    \node[font=\small, text=primaryGreen] at (7.5, -0.5) {97.5\%};
    \node[font=\small, text=primaryGreen] at (7.5, -2) {98.3\%};
    
    % Pr√©cision globale
    \node[font=\bfseries, text=darkGreen] at (3.75, -3.5) {Pr√©cision Globale : 97.8\%};
    
\end{tikzpicture}
\end{center}

% ============================================
\newpage
\section{Impl√©mentation du Frontend}
% ============================================

\subsection{Configuration React + Vite}

\begin{techbox}{vite.config.ts}
\begin{verbatim}
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true
      }
    }
  }
})
\end{verbatim}
\end{techbox}

\subsection{Composant Flux Vid√©o}

\begin{techbox}{RealTimeDetection.tsx}
\begin{verbatim}
import React, { useState } from 'react';
import { motion } from 'framer-motion';

const RealTimeDetection: React.FC = () => {
  const [isStreaming, setIsStreaming] = useState(false);
  
  return (
    <div className="min-h-screen bg-gradient-to-br from-green-900 to-emerald-800 p-8">
      <motion.div 
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className="max-w-6xl mx-auto"
      >
        <h1 className="text-4xl font-bold text-white mb-8">
          üî• Real-Time Fire Detection
        </h1>
        
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Video Stream */}
          <div className="lg:col-span-2 bg-black/30 backdrop-blur-lg rounded-2xl p-4">
            {isStreaming ? (
              <img
                src="http://localhost:8000/video_feed"
                alt="Live Detection Stream"
                className="w-full rounded-xl"
              />
            ) : (
              <div className="aspect-video bg-gray-800 rounded-xl flex items-center justify-center">
                <p className="text-gray-400">Click Start to begin detection</p>
              </div>
            )}
          </div>
          
          {/* Controls */}
          <div className="space-y-4">
            <button
              onClick={() => setIsStreaming(!isStreaming)}
              className={`w-full py-4 rounded-xl font-bold text-white transition-all ${
                isStreaming 
                  ? 'bg-red-500 hover:bg-red-600' 
                  : 'bg-green-500 hover:bg-green-600'
              }`}
            >
              {isStreaming ? '‚èπ Stop Detection' : '‚ñ∂ Start Detection'}
            </button>
            
            <div className="bg-white/10 backdrop-blur-lg rounded-xl p-4">
              <h3 className="text-lg font-bold text-white mb-2">Statistics</h3>
              <div className="grid grid-cols-2 gap-4">
                <div className="bg-red-500/20 rounded-lg p-3 text-center">
                  <span className="text-2xl">üî•</span>
                  <p className="text-white font-bold">Fire</p>
                </div>
                <div className="bg-gray-500/20 rounded-lg p-3 text-center">
                  <span className="text-2xl">üí®</span>
                  <p className="text-white font-bold">Smoke</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </motion.div>
    </div>
  );
};

export default RealTimeDetection;
\end{verbatim}
\end{techbox}

\subsection{Composant Carte Interactive}

\begin{techbox}{HotspotMap.tsx - Carte Leaflet}
\begin{verbatim}
import React from 'react';
import { MapContainer, TileLayer, CircleMarker, Popup } from 'react-leaflet';
import 'leaflet/dist/leaflet.css';

interface Hotspot {
  latitude: number;
  longitude: number;
  brightness: number;
  confidence: string;
  spreadRadius: number;
}

const getColorByConfidence = (confidence: string): string => {
  switch (confidence.toLowerCase()) {
    case 'high': return '#DC2626';    // Rouge
    case 'nominal': return '#F59E0B'; // Orange
    case 'low': return '#FCD34D';     // Jaune
    default: return '#6B7280';
  }
};

const HotspotMap: React.FC<{ hotspots: Hotspot[] }> = ({ hotspots }) => {
  return (
    <MapContainer 
      center={[31.7917, -7.0926]} 
      zoom={6} 
      className="h-[600px] w-full rounded-xl"
    >
      <TileLayer
        url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
        attribution='&copy; OpenStreetMap contributors'
      />
      
      {hotspots.map((spot, index) => (
        <React.Fragment key={index}>
          {/* Cercle de propagation */}
          <CircleMarker
            center={[spot.latitude, spot.longitude]}
            radius={spot.spreadRadius * 5}
            pathOptions={{
              color: getColorByConfidence(spot.confidence),
              fillColor: getColorByConfidence(spot.confidence),
              fillOpacity: 0.2
            }}
          />
          
          {/* Marqueur central */}
          <CircleMarker
            center={[spot.latitude, spot.longitude]}
            radius={8}
            pathOptions={{
              color: getColorByConfidence(spot.confidence),
              fillColor: getColorByConfidence(spot.confidence),
              fillOpacity: 0.8
            }}
          >
            <Popup>
              <div className="text-sm">
                <p><strong>Brightness:</strong> {spot.brightness}K</p>
                <p><strong>Confidence:</strong> {spot.confidence}</p>
                <p><strong>Spread:</strong> {spot.spreadRadius.toFixed(2)} km</p>
                <a 
                  href={`https://maps.google.com/?q=${spot.latitude},${spot.longitude}`}
                  target="_blank"
                  className="text-blue-500 underline"
                >
                  View on Google Maps
                </a>
              </div>
            </Popup>
          </CircleMarker>
        </React.Fragment>
      ))}
    </MapContainer>
  );
};

export default HotspotMap;
\end{verbatim}
\end{techbox}

% ============================================
\newpage
\section{Int√©gration des Services Externes}
% ============================================

\subsection{API NASA FIRMS}

\begin{infobox}{Configuration NASA FIRMS}
\begin{itemize}[leftmargin=0.5cm, itemsep=5pt]
    \item \textbf{URL de base :} \texttt{https://firms.modaps.eosdis.nasa.gov/api/area/csv}
    \item \textbf{Authentification :} MAP\_KEY (gratuit apr√®s inscription)
    \item \textbf{Source de donn√©es :} VIIRS\_SNPP\_NRT (Near Real-Time)
    \item \textbf{Format :} CSV avec colonnes latitude, longitude, brightness, confidence, frp
    \item \textbf{Latence :} ~3 heures apr√®s passage satellite
\end{itemize}
\end{infobox}

\subsection{Sentinel Hub}

\begin{infobox}{Configuration Sentinel Hub}
\begin{itemize}[leftmargin=0.5cm, itemsep=5pt]
    \item \textbf{Authentification :} OAuth2 Client Credentials
    \item \textbf{API :} Process API v1
    \item \textbf{Type de donn√©es :} Sentinel-2 L2A (atmosph√©riquement corrig√©)
    \item \textbf{Evalscripts :} True Color et Fire Detection (SWIR enhanced)
    \item \textbf{R√©solution :} 10m/pixel (bandes visibles)
\end{itemize}
\end{infobox}

\subsection{Services de Notification}

\begin{techbox}{telegram\_service.py}
\begin{verbatim}
import requests

class TelegramService:
    API_URL = "https://api.telegram.org/bot{token}"
    
    def __init__(self, token: str, chat_id: str):
        self.token = token
        self.chat_id = chat_id
        self.base_url = self.API_URL.format(token=token)
    
    def send_alert(self, message: str, image_path: str = None):
        """Envoie une alerte Telegram avec image optionnelle."""
        if image_path:
            with open(image_path, 'rb') as photo:
                response = requests.post(
                    f"{self.base_url}/sendPhoto",
                    data={"chat_id": self.chat_id, "caption": message, "parse_mode": "Markdown"},
                    files={"photo": photo}
                )
        else:
            response = requests.post(
                f"{self.base_url}/sendMessage",
                data={"chat_id": self.chat_id, "text": message, "parse_mode": "Markdown"}
            )
        return response.json()
\end{verbatim}
\end{techbox}

\vspace{1cm}

% Transition
\begin{center}
\begin{tikzpicture}
    \node[
        fill=primaryGreen!10,
        draw=primaryGreen,
        line width=1.5pt,
        rounded corners=12pt,
        inner sep=20pt,
        text width=13cm,
        align=center
    ] {
        \textcolor{primaryGreen}{\fontsize{24}{28}\selectfont\faArrowCircleRight}\\[15pt]
        \large\textbf{Chapitre Suivant}\\[10pt]
        \normalsize Le prochain chapitre pr√©sente les r√©sultats obtenus,\\
        les d√©monstrations du syst√®me et l'√©valuation des performances.\\[10pt]
        \textit{\textcolor{textGray}{Chapitre VI --- R√©sultats et √âvaluation}}
    };
\end{tikzpicture}
\end{center}

\end{document}
